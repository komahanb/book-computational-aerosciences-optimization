#!/usr/bin/env python3
"""Generate build/chapters.tex from manifest.yml."""
from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any, Dict, List

HEADER = "% Auto-generated by scripts/gen_book.py. Do not edit manually."


def _append(lines: List[str], text: str | None) -> None:
    if text:
        lines.append(text)


def render_part(part: Dict[str, Any], lines: List[str], appendix_inserted: bool) -> bool:
    if part.get("appendix") and not appendix_inserted:
        lines.append(r"\appendix")
        appendix_inserted = True
    title = part.get("title")
    if title:
        lines.append(rf"\part{{{title}}}")
        label = part.get("label")
        if label:
            lines.append(rf"\label{{{label}}}")
    _append(lines, part.get("preamble"))
    for chapter in part.get("chapters", []):
        _append(lines, chapter.get("preamble"))
        number = chapter.get("chapter_number")
        if number is not None:
            try:
                number_int = int(number)
            except ValueError as exc:  # pragma: no cover - invalid config
                raise SystemExit(f"Invalid chapter_number '{number}'") from exc
            lines.append(rf"\setcounter{{chapter}}{{{number_int - 1}}}")
        slug = chapter.get("slug")
        if not slug:
            raise SystemExit("Each chapter entry requires a 'slug'.")
        lines.append(rf"\loadchapter{{{slug}}}")
        _append(lines, chapter.get("postamble"))
    return appendix_inserted


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate chapter include list")
    parser.add_argument("structure", type=Path)
    parser.add_argument("output", type=Path)
    args = parser.parse_args()

    config = json.loads(args.structure.read_text())
    parts = config.get("parts", [])
    lines: List[str] = [HEADER]
    appendix_inserted = False
    for part in parts:
        appendix_inserted = render_part(part, lines, appendix_inserted)
    lines.append("")  # newline at end

    args.output.parent.mkdir(parents=True, exist_ok=True)
    content = "\n".join(lines)
    if args.output.exists() and args.output.read_text() == content:
        return
    args.output.write_text(content)


if __name__ == "__main__":
    main()
